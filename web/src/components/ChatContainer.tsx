"use client";

/**
 * Chat container component with AG-UI SDK integration.
 * AI instructions are handled server-side in agent.py - this is a pure UI layer.
 *
 * State sharing is set up between Python backend and frontend via AG-UI protocol.
 * Progress indicators are rendered based on state updates from the Python agent.
 *
 * Citations are rendered via custom markdownTagRenderers that handle <cite> tags
 * generated by the backend's citation processor. Each assistant message displays
 * its own sources accordion below the message content.
 */

import { useState, useCallback, useEffect, useRef, createContext, useContext } from "react";
import { Message } from "@ag-ui/client";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import rehypeRaw from "rehype-raw";
import { Loader2, ThumbsUp, ThumbsDown } from "lucide-react";
import {
  sourceTagRenderers,
  CitationProvider,
  MessageCitationProvider,
  SourcesAccordion,
  SourceViewDialog,
  useCitationContext,
} from "./Sources";
import { AgentChat, AssistantMessageRenderProps, ExtendedMessage, VesselLookup } from "./AgentChat";
import { getMessages, touchConversation, generateTitle, submitFeedback, listVessels } from "@/lib/conversations";
import { trackFeedback } from "@/lib/langfuse";


// Context for passing feedback handlers to custom AssistantMessage
type FeedbackContextType = {
  onThumbsUp: (message: Message) => void;
  onThumbsDown: (message: Message) => void;
};
const FeedbackContext = createContext<FeedbackContextType | null>(null);

function FeedbackButtons({ message }: { message: Message }) {
  const feedback = useContext(FeedbackContext);
  const [selected, setSelected] = useState<"up" | "down" | null>(null);

  if (!feedback || !message || !message.content) return null;

  const handleThumbsUp = () => {
    if (selected === "up") return;
    setSelected("up");
    feedback.onThumbsUp(message);
  };

  const handleThumbsDown = () => {
    if (selected === "down") return;
    setSelected("down");
    feedback.onThumbsDown(message);
  };

  return (
    <div className="flex items-center gap-1 mt-2">
      <button
        onClick={handleThumbsUp}
        className={`p-1.5 rounded hover:bg-gray-100 transition-colors ${
          selected === "up" ? "text-green-600 bg-green-50" : "text-gray-400 hover:text-gray-600"
        }`}
        title="Helpful"
        disabled={selected !== null}
      >
        <ThumbsUp className="h-4 w-4" />
      </button>
      <button
        onClick={handleThumbsDown}
        className={`p-1.5 rounded hover:bg-gray-100 transition-colors ${
          selected === "down" ? "text-red-600 bg-red-50" : "text-gray-400 hover:text-gray-600"
        }`}
        title="Not helpful"
        disabled={selected !== null}
      >
        <ThumbsDown className="h-4 w-4" />
      </button>
    </div>
  );
}

/**
 * Transform raw [C:chunk_id] citation markers to <cite> tags.
 * Fallback for messages where backend processing didn't occur.
 */
function transformRawCitations(content: string): string {
  const citationPattern = /\[C:([a-f0-9]+)\]/gi;
  let index = 1;
  const indexMap = new Map<string, number>();

  return content.replace(citationPattern, (_, chunkId) => {
    const lowerChunkId = chunkId.toLowerCase();
    if (!indexMap.has(lowerChunkId)) {
      indexMap.set(lowerChunkId, index++);
    }
    return `<cite id="${lowerChunkId}">${indexMap.get(lowerChunkId)}</cite>`;
  });
}

/**
 * Custom assistant message component that renders sources below each response.
 * Each message gets its own MessageCitationProvider to isolate citations per response.
 */
function CustomAssistantMessage({ message, isStreaming, streamingContent }: AssistantMessageRenderProps) {
  const { onViewCitation } = useCitationContext();
  const content = isStreaming && streamingContent ? streamingContent : (message.content || "");

  return (
    <MessageCitationProvider onViewCitation={onViewCitation}>
      <div>
        <div className="prose prose-sm max-w-none prose-p:my-2 prose-headings:my-3 [&_ul]:list-disc [&_ul]:pl-5 [&_ol]:list-decimal [&_ol]:pl-5">
          <ReactMarkdown
            remarkPlugins={[remarkGfm]}
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            rehypePlugins={[rehypeRaw as any]}
            components={sourceTagRenderers}
          >
            {transformRawCitations(content)}
          </ReactMarkdown>
        </div>
        {isStreaming && (
          <div className="mt-2 flex items-center gap-2">
            <Loader2 className="h-4 w-4 animate-spin text-gray-400" />
          </div>
        )}
        {!isStreaming && content && (
          <>
            <div className="mt-3 mb-2">
              <SourcesAccordion />
            </div>
            {/* Verify we have content before showing feedback to avoid duplicates or empty state issues */}
            {message && message.content && <FeedbackButtons message={message} />}
          </>
        )}
      </div>
    </MessageCitationProvider>
  );
}


interface ChatContainerProps {
  /** Thread ID for loading conversation history */
  threadId: string;
  /** Authentication token for API requests */
  authToken: string;
  /** Whether the chat is read-only (e.g., archived conversations) */
  disabled?: boolean;
  /** Selected vessel ID for filtering search results */
  vesselId?: string | null;
}

export function ChatContainer({ threadId, authToken, disabled = false, vesselId }: ChatContainerProps) {
  // History loading state
  const [historyLoaded, setHistoryLoaded] = useState(false);
  const [initialMessages, setInitialMessages] = useState<ExtendedMessage[]>([]);
  const [vesselLookup, setVesselLookup] = useState<VesselLookup>({});
  const prevMessageCount = useRef(0);
  const titleGenerated = useRef(false);

  // Citation dialog state
  const [selectedChunkId, setSelectedChunkId] = useState<string | null>(null);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [linesToHighlight, setLinesToHighlight] = useState<[number, number][] | undefined>(undefined);

  const handleViewCitation = useCallback((chunkId: string, lines?: [number, number][]) => {
    setSelectedChunkId(chunkId);
    setLinesToHighlight(lines);
    setDialogOpen(true);
  }, []);

  // Load message history and vessel lookup on mount
  useEffect(() => {
    if (!threadId || historyLoaded) return;

    async function loadHistory() {
      try {
        // Load vessels for name lookup (in parallel with messages)
        const [history, vessels] = await Promise.all([
          getMessages(threadId),
          listVessels().catch(() => []), // Don't fail if vessels can't be loaded
        ]);

        // Build vessel lookup map
        const lookup: VesselLookup = {};
        for (const vessel of vessels) {
          lookup[vessel.id] = vessel.name;
        }
        setVesselLookup(lookup);

        if (history.length > 0) {
          // AG-UI Message format with vessel_id metadata
          const agMessages: ExtendedMessage[] = history.map((msg) => ({
            id: msg.id,
            role: msg.role as "user" | "assistant",
            content: msg.content,
            vessel_id: msg.vessel_id,
          }));
          setInitialMessages(agMessages);
          // Check if title was already generated (has user messages)
          titleGenerated.current = history.some((m) => m.role === "user");
        }
        prevMessageCount.current = history.length;
      } catch (error) {
        console.error("Failed to load message history:", error);
      } finally {
        setHistoryLoaded(true);
      }
    }

    loadHistory();
  }, [threadId, historyLoaded]);

  // Track message changes for auto-sync and title generation
  const handleMessagesChange = useCallback(
    (messages: Message[]) => {
      if (!threadId || !historyLoaded) return;
      if (messages.length > prevMessageCount.current) {
        // New message added - touch conversation to update timestamp
        touchConversation(threadId).catch(console.error);

        // Generate title on first user message
        if (!titleGenerated.current) {
          const userMessages = messages.filter((m) => m.role === "user");
          if (userMessages.length > 0) {
            const firstUserContent = userMessages[0].content;
            const content = typeof firstUserContent === "string" ? firstUserContent : "";
            if (content) {
              titleGenerated.current = true;
              generateTitle(threadId, content).catch(console.error);
            }
          }
        }
      }
      prevMessageCount.current = messages.length;
    },
    [threadId, historyLoaded]
  );

  // Feedback handlers for thumbs up/down
  const handleThumbsUp = useCallback(
    (message: Message) => {
      if (!threadId || !message.id) return;
      submitFeedback(threadId, message.id, 1).catch((error) => {
        console.error("Failed to submit positive feedback:", error);
      });
      // Track in Langfuse (sessionId = threadId for consistency)
      trackFeedback(threadId, message.id, 1);
    },
    [threadId]
  );

  const handleThumbsDown = useCallback(
    (message: Message) => {
      if (!threadId || !message.id) return;
      submitFeedback(threadId, message.id, 0).catch((error) => {
        console.error("Failed to submit negative feedback:", error);
      });
      // Track in Langfuse (sessionId = threadId for consistency)
      trackFeedback(threadId, message.id, 0);
    },
    [threadId]
  );

  const feedbackValue = { onThumbsUp: handleThumbsUp, onThumbsDown: handleThumbsDown };

  return (
    <FeedbackContext.Provider value={feedbackValue}>
      <CitationProvider onViewCitation={handleViewCitation}>
        <div className="flex-1 flex flex-col min-h-0 overflow-hidden">
          <AgentChat
            agentUrl="/api/agent"
            threadId={threadId}
            authToken={authToken}
            vesselId={vesselId}
            labels={{
              title: "MTSS Assistant",
              initial: "Welcome to MTSS. I'm your intelligent assistant for maritime technical support. Describe any vessel issue you're experiencing, and I'll analyze our comprehensive knowledge base to find relevant solutions and past incident resolutions.",
              placeholder: disabled
                ? "This conversation is archived (read-only)"
                : "Describe an issue or search for technical information...",
            }}
            disabled={disabled}
            className="flex-1 flex flex-col min-h-0"
            initialMessages={initialMessages}
            onMessagesChange={handleMessagesChange}
            renderAssistantMessage={CustomAssistantMessage}
            vesselLookup={vesselLookup}
          >
            {/* Show spinner while history is loading */}
            {!historyLoaded && (
              <div className="absolute inset-0 z-10 flex items-center justify-center bg-white/50 backdrop-blur-sm">
                <div className="flex flex-col items-center gap-2">
                  <div className="animate-spin rounded-full border-2 border-ncl-blue border-t-transparent h-8 w-8" />
                  <span className="text-sm text-ncl-blue font-medium">Loading history...</span>
                </div>
              </div>
            )}
          </AgentChat>

          {/* Dialog for viewing full source content */}
          <SourceViewDialog
            chunkId={selectedChunkId}
            open={dialogOpen}
            onOpenChange={setDialogOpen}
            linesToHighlight={linesToHighlight}
          />
        </div>
      </CitationProvider>
    </FeedbackContext.Provider>
  );
}
