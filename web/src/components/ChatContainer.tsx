"use client";

/**
 * Chat container component with CopilotKit integration.
 * AI instructions are handled server-side in agent.py - this is a pure UI layer.
 *
 * State sharing is set up between Python backend and frontend via LangGraph protocol.
 * Progress indicators are rendered via useCoAgentStateRender hook, which receives
 * real-time updates from copilotkit_emit_state() calls in the Python agent.
 *
 * Citations are rendered via custom markdownTagRenderers that handle <cite> tags
 * generated by the backend's citation processor. Each assistant message displays
 * its own sources accordion below the message content.
 */

import { useState, useCallback, useEffect, useRef } from "react";
import { CopilotChat } from "@copilotkit/react-ui";
import { useChatContext } from "@copilotkit/react-ui";
import type { AssistantMessageProps } from "@copilotkit/react-ui";
import { useCoAgent, useCoAgentStateRender, useCopilotChatInternal } from "@copilotkit/react-core";
import type { Message } from "@copilotkit/shared";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import rehypeRaw from "rehype-raw";
import "@copilotkit/react-ui/styles.css";
import { RAGState, initialRAGState } from "@/types/rag";
import {
  sourceTagRenderers,
  CitationProvider,
  MessageCitationProvider,
  SourcesAccordion,
  SourceViewDialog,
  useCitationContext,
} from "./Sources";
import { getMessages, touchConversation, generateTitle } from "@/lib/conversations";

function SearchProgress({ message }: { message: string }) {
  return (
    <div className="flex items-center gap-2 px-4 py-3 bg-blue-50 border border-blue-200 rounded-lg mx-4 my-2">
      <div className="animate-spin h-4 w-4 border-2 border-blue-500 border-t-transparent rounded-full" />
      <span className="text-sm text-blue-700">{message}</span>
    </div>
  );
}

/**
 * Transform raw [C:chunk_id] citation markers to <cite> tags.
 * Fallback for messages where backend processing didn't occur.
 */
function transformRawCitations(content: string): string {
  const citationPattern = /\[C:([a-f0-9]+)\]/gi;
  let index = 1;
  const indexMap = new Map<string, number>();

  return content.replace(citationPattern, (_, chunkId) => {
    const lowerChunkId = chunkId.toLowerCase();
    if (!indexMap.has(lowerChunkId)) {
      indexMap.set(lowerChunkId, index++);
    }
    return `<cite id="${lowerChunkId}">${indexMap.get(lowerChunkId)}</cite>`;
  });
}

/**
 * Custom assistant message component that renders sources below each response.
 * Each message gets its own MessageCitationProvider to isolate citations per response.
 *
 * Note: CopilotKit handles the avatar/wrapper - we only provide the message content.
 */
function CustomAssistantMessage(props: AssistantMessageProps) {
  const { icons } = useChatContext();
  const { message, isLoading } = props;
  const { onViewCitation } = useCitationContext();

  // generativeUI contains output from useCoAgentStateRender (e.g., SearchProgress)
  // It can be a function or a ReactNode
  const generativeUI = message?.generativeUI;
  const renderedGenerativeUI = typeof generativeUI === "function" ? generativeUI() : generativeUI;

  return (
    <MessageCitationProvider onViewCitation={onViewCitation}>
      <div>
        {/* Render generative UI (e.g., search progress from useCoAgentStateRender) */}
        {renderedGenerativeUI && <div className="mb-2">{renderedGenerativeUI}</div>}

        <div className="prose prose-sm max-w-none prose-p:my-2 prose-headings:my-3">
          <ReactMarkdown
            remarkPlugins={[remarkGfm]}
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            rehypePlugins={[rehypeRaw as any]}
            components={sourceTagRenderers}
          >
            {transformRawCitations(message?.content || "")}
          </ReactMarkdown>
        </div>
        {isLoading && (
          <div className="mt-2">
            {icons.spinnerIcon}
          </div>
        )}
        {!isLoading && (
          <div className="mt-3 mb-4">
            <SourcesAccordion />
          </div>
        )}
      </div>
    </MessageCitationProvider>
  );
}

interface ChatContainerProps {
  /** Thread ID for loading conversation history */
  threadId?: string;
  /** Whether the chat is read-only (e.g., archived conversations) */
  disabled?: boolean;
}

export function ChatContainer({ threadId, disabled }: ChatContainerProps) {
  const { state } = useCoAgent<RAGState>({
    name: "default",
    initialState: initialRAGState,
  });

  // CopilotKit hooks for history loading and reactive sync
  // Using useCopilotChatInternal to get access to setMessages which updates agent state
  const { messages, setMessages } = useCopilotChatInternal();
  const [historyLoaded, setHistoryLoaded] = useState(false);
  const prevMessageCount = useRef(0);
  const titleGenerated = useRef(false);

  // Load message history on mount
  // Using setTimeout to ensure CopilotChat is fully mounted
  useEffect(() => {
    if (!threadId || historyLoaded) return;

    async function loadHistory() {
      try {
        const history = await getMessages(threadId!);
        if (history.length > 0) {
          // Use setTimeout to ensure CopilotChat is fully mounted
          setTimeout(() => {
            // AG-UI Message format (plain objects, not class instances)
            const copilotMessages: Message[] = history.map((msg) => ({
              id: msg.id,
              role: msg.role as "user" | "assistant",
              content: msg.content,
            }));
            setMessages(copilotMessages);
          }, 100);
          // Check if title was already generated (has user messages)
          titleGenerated.current = history.some((m) => m.role === "user");
        }
        prevMessageCount.current = history.length;
      } catch (error) {
        console.error("Failed to load message history:", error);
      } finally {
        setHistoryLoaded(true);
      }
    }

    loadHistory();
  }, [threadId, historyLoaded, setMessages]);

  // Auto-sync metadata when messages change (replaces onMessageSent callback)
  useEffect(() => {
    if (!threadId || !historyLoaded) return;
    if (messages.length > prevMessageCount.current) {
      // New message added - touch conversation to update timestamp
      touchConversation(threadId).catch(console.error);

      // Generate title on first user message
      if (!titleGenerated.current) {
        const userMessages = messages.filter((m) => m.role === "user");
        if (userMessages.length > 0) {
          const firstUserContent = userMessages[0].content;
          const content = typeof firstUserContent === "string" ? firstUserContent : "";
          if (content) {
            titleGenerated.current = true;
            generateTitle(threadId, content).catch(console.error);
          }
        }
      }
    }
    prevMessageCount.current = messages.length;
  }, [messages.length, threadId, historyLoaded]);

  // Citation dialog state
  const [selectedChunkId, setSelectedChunkId] = useState<string | null>(null);
  const [dialogOpen, setDialogOpen] = useState(false);

  const handleViewCitation = useCallback((chunkId: string) => {
    setSelectedChunkId(chunkId);
    setDialogOpen(true);
  }, []);

  // Render search progress during agent execution
  useCoAgentStateRender<RAGState>({
    name: "default",
    render: ({ state }) => {
      if (state.search_progress) {
        return <SearchProgress message={state.search_progress} />;
      }
      return null;
    },
  });

  return (
    <CitationProvider onViewCitation={handleViewCitation}>
      <div className="flex-1 flex flex-col h-[calc(100vh-3.5rem)]">
        {state.error_message && (
          <div className="px-4 py-2 bg-red-50 border-b border-red-200">
            <div className="text-sm text-red-700">
              Error: {state.error_message}
            </div>
          </div>
        )}
        <CopilotChat
          labels={{
            title: "MTSS Assistant",
            initial: "Hello! I can help you find solutions to technical issues on your vessel. Ask me about past maintenance problems, equipment failures, or search our knowledge base for technical documentation and procedures.",
            placeholder: disabled
              ? "This conversation is archived (read-only)"
              : "Describe an issue or search for technical information...",
          }}
          className={`flex-1 flex flex-col [&_.copilotKitChat]:flex-1 [&_.copilotKitChat]:flex [&_.copilotKitChat]:flex-col [&_.copilotKitMessages]:flex-1 [&_.copilotKitMessages]:overflow-y-auto ${
            disabled ? "[&_.copilotKitInput]:opacity-50 [&_.copilotKitInput]:pointer-events-none" : ""
          }`}
          markdownTagRenderers={sourceTagRenderers}
          AssistantMessage={CustomAssistantMessage}
        />

        {/* Dialog for viewing full source content */}
        <SourceViewDialog
          chunkId={selectedChunkId}
          open={dialogOpen}
          onOpenChange={setDialogOpen}
        />
      </div>
    </CitationProvider>
  );
}
